#!/bin/bash

ABORTAG="[abort]"
ERRTAG="[error]"
WARNTAG="[warning]"
SYSLOGTAG="tingle"

export PATH=/sbin:/bin:/usr/sbin:/usr/bin

UNIMPORTANT=/etc/tingle/unimportant-packages

exec 3>&1
exec 4>&2

trap bail INT QUIT TERM ERR

declare -a ignore_rvs

abort() {
    # We could pass -s to logger and let it do the echo out to stderr, 
    # but I don't want to pass ABORTAG and friends into syslog.  That's 
    # what syslog priorities are for.

    log_error "$@"
    echo "$ABORTAG $@" >&4
    exit_clean 2
}

error() {
    log_error "$@"
    echo "$ERRTAG $@" >&4
    exit_clean 1
}

warning() {
    log_warning "$@"
    debug "$WARNTAG $@"
}

debug() {
    if ! is_interactive ; then
        exec 2>/dev/null
    fi

    echo "$@" >&2

    exec 2>&4
}

bail() {
    exit_clean 1
}

buffer() {
    echo "$TMP_DIR/$(echo "$(date +%s)-$RANDOM-$@"  | sed "s/[ \t/-]//g")"
}

# For commands that return non-zero without actually failing.
do_ignore_derp() {
    # Since we can't reliably detect failures, assume stderr is useless.
    if ! is_interactive ; then
        exec 2>/dev/null
    fi

    $@ || true

    exec 2>&4
}

do_or_die() {
    local b suppress=no

    b="$(buffer $@)"
    exec 2>"$b"
    set +e
    $@
    rv=$?
    set -e
    exec 2>&4
    if [ $rv -ne 0 ]; then
        if [ ! -z $ignore_rvs ]; then
            for i in $(seq 0 $((${#ignore_rvs[@]} - 1))); do
                if [ $rv -eq "${ignore_rvs[$i]}" ]; then
                    suppress=yes
                fi
            done
            ignore_rvs=( )
        fi
        if [ "$suppress" != "yes" ]; then
            cat "$b" >&2
            echo >&2
            error "\`$@' returned non-zero"
        fi
    fi
}

execd() {
    local b_err b_out d="$1"

    if [ ! -d "$d" ] ; then
        warning "$d is not a valid hook scripts directory"
    else
        debug "Scanning $d for hook scripts"
        for i in $(find "${d}" -mindepth 1 -maxdepth 1 -type f); do
            if [ -x "$i" ]; then
                debug "Executing $i"
                b_out="$(buffer $i)"
                b_err="$(buffer $i)"
                exec 1>"$b_out"
                exec 2>"$b_err"
                set +e
                "$i"
                rv=$?
                set -e
                exec 1>&3
                exec 2>&4
                if [ $rv -ne 0 ]; then
                    cat "$b_out" >&1
                    cat "$b_err" >&2
                    echo >&2
                    error "\`$i' returned non-zero"
                fi
            else
                warning "$i is not executable"
            fi
        done
    fi
}

exit_clean() {
    local STATUS

    STATUS=0
    [ -n "$1" ] && STATUS=$1
    nuke_tmp
    exit $STATUS
}

invoke_os_flavour() {
    local BASE="$1" FLAVA SUFFIX

    case "$(os_flavour)" in
        CentOS|RedHat)
            SUFFIX="rpm"
        ;;
        Debian)
            SUFFIX="dpkg"
        ;;
        *)
            error "tingle does not recognise your operating system"
        ;;
    esac

    FLAVA="${TINGLE_PREFIX}/lib/tingle/${BASE}-${SUFFIX}"
    if [ -x "$FLAVA" ] ; then
        debug "Running $(basename $FLAVA)"
        "$FLAVA"
    else
        error "Could not execute $FLAVA"
    fi
}

is_interactive() {
    tty -s && test "${TINGLE_NONINTERACTIVE:+x}" != x && \
      return 0
    return 1
}

log_error() {
    logger -p user.err -t "$SYSLOGTAG" -- "$@" || true
}

log_info() {
    logger -t "$SYSLOGTAG" -- "$@" || true
}

log_warning() {
    logger -p user.warn -t "$SYSLOGTAG" -- "$@" || true
}

nuke_tmp() {
    rm -fr "$TMP_DIR"
}

os_flavour() {
    if [ -e /etc/redhat-release ]; then
        if grep -qi centos /etc/redhat-release ; then
            echo "CentOS"
        elif grep -qi scientific /etc/redhat-release ; then
            echo "Scientific"
        else
            echo "RedHat"
        fi
    elif [ -e /etc/debian_version ]; then
        # You're one of those Ubuntu users, are ye?  See bug #19353.
        echo "Debian"
    fi
}

# All potentially disastrous automated processes need a killswitch 
# within easy reach.
KILLSWITCH="${TINGLE_PREFIX}/etc/tingle/noupdate"
if [ -f $KILLSWITCH ]; then
    abort "Aborting on killswitch.  Remove $KILLSWITCH and try again."
fi

TMP_DIR="$(mktemp -d -t tingle.XXXXXX)"
